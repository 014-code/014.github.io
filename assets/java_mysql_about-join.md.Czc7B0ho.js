import{_ as i,o as a,c as t,a0 as n}from"./chunks/framework.CSGB4SNl.js";const g=JSON.parse('{"title":"JOIN 连接：到底能不能写 JOIN？","description":"","frontmatter":{},"headers":[],"relativePath":"java/mysql/about-join.md","filePath":"java/mysql/about-join.md"}'),h={name:"java/mysql/about-join.md"};function e(l,s,p,k,d,r){return a(),t("div",null,[...s[0]||(s[0]=[n(`<h1 id="join-连接-到底能不能写-join" tabindex="-1">JOIN 连接：到底能不能写 JOIN？ <a class="header-anchor" href="#join-连接-到底能不能写-join" aria-label="Permalink to &quot;JOIN 连接：到底能不能写 JOIN？&quot;">​</a></h1><p>很多开发同学下意识地认为 <strong>JOIN 会降低 SQL 性能</strong>，于是把多表查询拆成单表查询。但这样反而更慢——因为不了解 JOIN 的实现过程。</p><h2 id="一、join-的两种算法" tabindex="-1">一、JOIN 的两种算法 <a class="header-anchor" href="#一、join-的两种算法" aria-label="Permalink to &quot;一、JOIN 的两种算法&quot;">​</a></h2><p>MySQL 8.0 支持两种 JOIN 算法：</p><table tabindex="0"><thead><tr><th>算法</th><th>适用场景</th><th>特点</th></tr></thead><tbody><tr><td><strong>Nested Loop Join</strong></td><td>OLTP（小数据量、有索引）</td><td>用索引逐行匹配</td></tr><tr><td><strong>Hash Join</strong></td><td>OLAP（大数据量、无索引）</td><td>用哈希表批量匹配</td></tr></tbody></table><h3 id="_1-nested-loop-join" tabindex="-1">1. Nested Loop Join <a class="header-anchor" href="#_1-nested-loop-join" aria-label="Permalink to &quot;1. Nested Loop Join&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>驱动表 R → 通过索引查询关联表 S</span></span></code></pre></div><p><strong>示例</strong>：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders o </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INNER JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lineitem l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> o</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">o_orderkey</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> l</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">l_orderkey</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> o</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">o_orderdate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;1994-02-01&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>执行流程：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1. 用 idx_orderdate 过滤 orders（驱动表）</span></span>
<span class="line"><span>2. 对每条订单，用主键查 lineitem</span></span>
<span class="line"><span>3. 返回匹配结果</span></span></code></pre></div><p><strong>驱动表选择原则</strong>：谁过滤后的数据量少，谁就是驱动表。</p><h3 id="_2-hash-join" tabindex="-1">2. Hash Join <a class="header-anchor" href="#_2-hash-join" aria-label="Permalink to &quot;2. Hash Join&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>扫描小表 → 创建哈希表 → 扫描大表 → 哈希匹配</span></span></code></pre></div><p>适用于：<strong>没有索引</strong>、<strong>数据量大</strong>的场景。</p><h2 id="二、oltp-能不能写-join" tabindex="-1">二、OLTP 能不能写 JOIN？ <a class="header-anchor" href="#二、oltp-能不能写-join" aria-label="Permalink to &quot;二、OLTP 能不能写 JOIN？&quot;">​</a></h2><p><strong>完全可以！</strong> 但要满足两个条件：</p><ol><li>WHERE 条件能过滤到少量数据</li><li>JOIN 的列上有索引</li></ol><p><strong>示例</strong>（用户查订单）：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> o_custkey, o_orderdate, o_totalprice, p_name </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders o, lineitem l, part p</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> o</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">o_orderkey</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> l</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">l_orderkey</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  AND</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> l</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">l_partkey</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">p_partkey</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  AND</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> o</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">o_custkey</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ?      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 用户ID过滤</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ORDER BY</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> o</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">o_orderdate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> DESC</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LIMIT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>执行计划显示只扫描 30 条数据，<strong>无论表有多大，速度都很快</strong>。</p><h2 id="三、join-使用建议" tabindex="-1">三、JOIN 使用建议 <a class="header-anchor" href="#三、join-使用建议" aria-label="Permalink to &quot;三、JOIN 使用建议&quot;">​</a></h2><table tabindex="0"><thead><tr><th>场景</th><th>能否写 JOIN</th><th>注意事项</th></tr></thead><tbody><tr><td>OLTP（电商、支付）</td><td>可以</td><td>确保驱动表数据量少、有关联索引</td></tr><tr><td>OLAP（报表、分析）</td><td>可以</td><td>大数据量用 Hash Join</td></tr><tr><td>无索引关联</td><td>慎用</td><td>先加索引或考虑拆分成多次查询</td></tr></tbody></table><p><strong>核心原则</strong>：相信优化器，它比你更专业。确保索引到位，放心写 JOIN！</p>`,24)])])}const c=i(h,[["render",e]]);export{g as __pageData,c as default};
