import{_ as n,C as l,o as i,c as h,a0 as a,b as r,w as t,a as d,E as o,a1 as p}from"./chunks/framework.CSGB4SNl.js";const b=JSON.parse('{"title":"02 线程池掌故：管理并发的秘籍","description":"","frontmatter":{},"headers":[],"relativePath":"java/concurrent/concurrent-02.md","filePath":"java/concurrent/concurrent-02.md"}'),k={name:"java/concurrent/concurrent-02.md"};function E(c,s,g,u,y,A){const e=l("Mermaid");return i(),h("div",null,[s[1]||(s[1]=a('<h1 id="_02-线程池掌故-管理并发的秘籍" tabindex="-1">02 线程池掌故：管理并发的秘籍 <a class="header-anchor" href="#_02-线程池掌故-管理并发的秘籍" aria-label="Permalink to &quot;02 线程池掌故：管理并发的秘籍&quot;">​</a></h1><p>在上一章，我们学习了线程的基本使用。但有一个问题：<code>线程数量越多越好吗？</code></p><p>答案是 <strong>否定的</strong>。线程切换需要保存/恢复执行上下文，消耗大量资源。如果无限制创建线程，会导致线程切换频繁、内存耗尽等问题。</p><p>因此，<strong>需要线程池来统一管理线程</strong>。</p><h2 id="一、线程池是什么" tabindex="-1">一、线程池是什么 <a class="header-anchor" href="#一、线程池是什么" aria-label="Permalink to &quot;一、线程池是什么&quot;">​</a></h2><p>线程池是一种基于池化思想的线程管理工具：</p><ul><li>维护多个<strong>常驻线程</strong>，重复利用</li><li>避免线程反复创建和销毁的开销</li><li>控制线程数量，防止资源耗尽</li><li>支持弹性扩缩容</li></ul><h2 id="二、线程池的核心参数" tabindex="-1">二、线程池的核心参数 <a class="header-anchor" href="#二、线程池的核心参数" aria-label="Permalink to &quot;二、线程池的核心参数&quot;">​</a></h2><table tabindex="0"><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>corePoolSize</strong></td><td>核心线程数，永远不会被回收</td></tr><tr><td><strong>maximumPoolSize</strong></td><td>最大线程数，突发任务时临时扩展</td></tr><tr><td><strong>keepAliveTime</strong></td><td>空闲线程存活时间</td></tr><tr><td><strong>unit</strong></td><td>时间单位（秒/分钟/小时）</td></tr><tr><td><strong>workQueue</strong></td><td>任务队列，存放待执行任务</td></tr><tr><td><strong>threadFactory</strong></td><td>线程工厂，控制如何创建线程</td></tr><tr><td><strong>handler</strong></td><td>拒绝策略，任务过多时的兜底方案</td></tr></tbody></table><h3 id="_1-线程池如何处理任务" tabindex="-1">1. 线程池如何处理任务？ <a class="header-anchor" href="#_1-线程池如何处理任务" aria-label="Permalink to &quot;1. 线程池如何处理任务？&quot;">​</a></h3>',10)),(i(),r(p,null,{default:t(()=>[o(e,{id:"mermaid-116",class:"mermaid my-class",graph:"flowchart%20TD%0A%20%20%20%20A%5B%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%5D%20--%3E%20B%7B%E7%BA%BF%E7%A8%8B%E6%95%B0%20%3C%20corePoolSize%3F%7D%0A%20%20%20%20B%20--%3E%7C%E6%98%AF%7C%20C%5B%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%5D%0A%20%20%20%20B%20--%3E%7C%E5%90%A6%7C%20D%7B%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%3F%7D%0A%20%20%20%20C%20--%3E%20E%5B%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%5D%0A%20%20%20%20D%20--%3E%7C%E5%90%A6%7C%20F%5B%E6%94%BE%E5%85%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%5D%0A%20%20%20%20D%20--%3E%7C%E6%98%AF%7C%20G%7B%E7%BA%BF%E7%A8%8B%E6%95%B0%20%3C%20maximumPoolSize%3F%7D%0A%20%20%20%20F%20--%3E%20E%0A%20%20%20%20G%20--%3E%7C%E6%98%AF%7C%20H%5B%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%5D%0A%20%20%20%20G%20--%3E%7C%E5%90%A6%7C%20I%5B%E8%A7%A6%E5%8F%91%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%5D%0A%20%20%20%20H%20--%3E%20E%0A%20%20%20%20I%20--%3E%20J%5B%E6%8B%92%E7%BB%9D%E4%BB%BB%E5%8A%A1%5D%0A"})]),fallback:t(()=>[...s[0]||(s[0]=[d(" Loading... ",-1)])]),_:1})),s[2]||(s[2]=a(`<p><strong>处理流程</strong>：</p><ol><li>线程数 &lt; corePoolSize → 创建新线程执行任务</li><li>线程数 &gt;= corePoolSize → 任务放入队列等待</li><li>队列满了 + 线程数 &lt; maximumPoolSize → 创建新线程执行</li><li>队列满了 + 线程数 = maximumPoolSize → 触发拒绝策略</li><li>任务高峰期过后 → 回收多余线程至 corePoolSize</li></ol><h3 id="_2-workqueue-常用类型" tabindex="-1">2. workQueue 常用类型 <a class="header-anchor" href="#_2-workqueue-常用类型" aria-label="Permalink to &quot;2. workQueue 常用类型&quot;">​</a></h3><table tabindex="0"><thead><tr><th>队列类型</th><th>特点</th></tr></thead><tbody><tr><td><strong>SynchronousQueue</strong></td><td>无容量交换队列，线程数轻松达到 maximumPoolSize</td></tr><tr><td><strong>LinkedBlockingQueue</strong></td><td>无界队列，容量为 <code>Integer.MAX_VALUE</code>，容易 OOM</td></tr><tr><td><strong>ArrayBlockingQueue</strong></td><td>有界队列，需要设置长度，maximumPoolSize 生效</td></tr><tr><td><strong>DelayedWorkQueue</strong></td><td>延时队列，适用于定时线程池</td></tr></tbody></table><p><strong>使用建议</strong>：</p><ul><li>需要弹性扩缩容 → 使用 <code>ArrayBlockingQueue</code></li><li>需要任务排队但不限制长度 → 使用 <code>LinkedBlockingQueue</code>（注意 OOM 风险）</li></ul><h3 id="_3-拒绝策略" tabindex="-1">3. 拒绝策略 <a class="header-anchor" href="#_3-拒绝策略" aria-label="Permalink to &quot;3. 拒绝策略&quot;">​</a></h3><p>当线程池满了，后续任务会被拒绝。JDK 提供 4 种策略：</p><table tabindex="0"><thead><tr><th>策略</th><th>说明</th></tr></thead><tbody><tr><td><strong>AbortPolicy</strong></td><td>抛出 <code>RejectedExecutionException</code> 异常（默认）</td></tr><tr><td><strong>DiscardPolicy</strong></td><td>静默丢弃任务，不抛异常</td></tr><tr><td><strong>DiscardOldestPolicy</strong></td><td>丢弃队列中最旧的任务</td></tr><tr><td><strong>CallerRunsPolicy</strong></td><td>由提交任务的线程自己执行</td></tr></tbody></table><p><strong>选择建议</strong>：</p><ul><li>日志/统计任务 → <code>DiscardPolicy</code></li><li>需要通知调用者 → <code>AbortPolicy</code></li><li>必须执行的任务 → <code>CallerRunsPolicy</code>（注意会阻塞调用者）</li></ul><h3 id="_4-核心线程超时回收" tabindex="-1">4. 核心线程超时回收 <a class="header-anchor" href="#_4-核心线程超时回收" aria-label="Permalink to &quot;4. 核心线程超时回收&quot;">​</a></h3><p>默认情况下，核心线程即使空闲也不会被回收。可以通过设置允许回收：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">threadPoolExecutor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allowCoreThreadTimeOut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>设置后，核心线程空闲超时也会被回收。</p><h2 id="三、jdk-默认线程池-不推荐使用" tabindex="-1">三、JDK 默认线程池（不推荐使用） <a class="header-anchor" href="#三、jdk-默认线程池-不推荐使用" aria-label="Permalink to &quot;三、JDK 默认线程池（不推荐使用）&quot;">​</a></h2><h3 id="_1-定长线程池" tabindex="-1">1. 定长线程池 <a class="header-anchor" href="#_1-定长线程池" aria-label="Permalink to &quot;1. 定长线程池&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExecutorService fixedThreadPool </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newFixedThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ul><li>corePoolSize = maximumPoolSize = 10</li><li>使用无界队列</li><li><strong>缺陷</strong>：任务堆积会导致 OOM</li></ul><h3 id="_2-单线程池" tabindex="-1">2. 单线程池 <a class="header-anchor" href="#_2-单线程池" aria-label="Permalink to &quot;2. 单线程池&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExecutorService singleThreadExecutor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newSingleThreadExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><ul><li>同一时间只执行一个任务</li><li><strong>缺陷</strong>：与定长线程池相同</li></ul><h3 id="_3-缓存线程池" tabindex="-1">3. 缓存线程池 <a class="header-anchor" href="#_3-缓存线程池" aria-label="Permalink to &quot;3. 缓存线程池&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExecutorService cachedThreadPool </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newCachedThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><ul><li>corePoolSize = 0，maximumPoolSize = <code>Integer.MAX_VALUE</code></li><li>使用 SynchronousQueue</li><li>空闲线程 60 秒后回收</li><li><strong>缺陷</strong>：极限情况下会无限制创建线程</li></ul><h3 id="_4-定时线程池" tabindex="-1">4. 定时线程池 <a class="header-anchor" href="#_4-定时线程池" aria-label="Permalink to &quot;4. 定时线程池&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ScheduledExecutorService scheduledExecutorService </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newScheduledThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><strong>常用方法</strong>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 延迟 1 秒后执行一次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scheduledExecutorService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(task, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TimeUnit.SECONDS);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 延迟 1 秒后开始，每隔 2 秒执行一次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scheduledExecutorService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scheduleAtFixedRate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(task, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TimeUnit.SECONDS);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 任务执行完后，延迟 2 秒再执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scheduledExecutorService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scheduleWithFixedDelay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(task, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TimeUnit.SECONDS);</span></span></code></pre></div><h2 id="四、线程池状态" tabindex="-1">四、线程池状态 <a class="header-anchor" href="#四、线程池状态" aria-label="Permalink to &quot;四、线程池状态&quot;">​</a></h2><table tabindex="0"><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td><strong>RUNNING</strong></td><td>正常运行，接受新任务</td></tr><tr><td><strong>SHUTDOWN</strong></td><td>不接受新任务，执行完已提交任务</td></tr><tr><td><strong>STOP</strong></td><td>不接受新任务，不执行已提交任务</td></tr><tr><td><strong>TIDYING</strong></td><td>所有任务终止，清理中</td></tr><tr><td><strong>TERMINATED</strong></td><td>已终止</td></tr></tbody></table><p><strong>状态切换</strong>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shutdown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// RUNNING → SHUTDOWN</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shutdownNow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// RUNNING → STOP</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">awaitTermination</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等待进入 TERMINATED</span></span></code></pre></div><h2 id="五、自定义线程池示例" tabindex="-1">五、自定义线程池示例 <a class="header-anchor" href="#五、自定义线程池示例" aria-label="Permalink to &quot;五、自定义线程池示例&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThreadPoolExecutor executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPoolExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// corePoolSize</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,                     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// maximumPoolSize</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    60L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TimeUnit.SECONDS, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// keepAliveTime</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayBlockingQueue&lt;&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 队列</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyThreadFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 线程工厂</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DiscardPolicy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 拒绝策略</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="六、总结" tabindex="-1">六、总结 <a class="header-anchor" href="#六、总结" aria-label="Permalink to &quot;六、总结&quot;">​</a></h2><p>线程池的核心价值：</p><ul><li><strong>资源控制</strong>：防止无限制创建线程</li><li><strong>性能提升</strong>：复用线程，减少创建销毁开销</li><li><strong>任务管理</strong>：队列缓冲、拒绝策略</li></ul><p><strong>阿里巴巴规范建议</strong>：不要使用 JDK 默认线程池创建方式，应使用 <code>ThreadPoolExecutor</code> 手动配置，避免 OOM 风险。</p>`,39))])}const C=n(k,[["render",E]]);export{b as __pageData,C as default};
